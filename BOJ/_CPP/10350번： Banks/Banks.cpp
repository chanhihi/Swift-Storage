/* ************************************************************************** */
/*                                                                            */
/*                                                      :::    :::    :::     */
/*   Problem Number: 10350                             :+:    :+:      :+:    */
/*                                                    +:+    +:+        +:+   */
/*   By: chanhihi <boj.kr/u/chanhihi>                +#+    +#+          +#+  */
/*                                                  +#+      +#+        +#+   */
/*   https://boj.kr/10350                          #+#        #+#      #+#    */
/*   Solved: 2024/10/03 08:10:47 by chanhihi      ###          ###   ##.kr    */
/*                                                                            */
/* ************************************************************************** */

// 이상한 나라의 월스트리트에는 n개의 은행이 있으며, 0 < n < 10000입니다. 각
// 은행은 정확히 두 개의 이웃, 즉 왼쪽(L)과 오른쪽(R) 이웃을 가지고 있습니다. 첫
// 번째 은행의 왼쪽 이웃은 마지막 은행이고, 마지막 은행의 오른쪽 이웃은 첫 번째
// 은행입니다. 각 은행 i (0 ≤ i < n)는 -32000 < k_i < 32000의 자본을 가지고
// 있습니다. 모든 은행의 자본을 합하면 전체 자본은 양수임이 보장됩니다.

// 만약 은행 i의 자본이 음수일 경우, 은행 요정이 마법을 사용하여 그 자본을
// 양수로 바꿀 수 있습니다. 예를 들어, k_i = -7인 경우, 마법을 사용하면 k_i =
// 7이 됩니다. 하지만 이 마법은 은행 i의 양쪽 이웃 은행에도 영향을 미칩니다.
// 양쪽 이웃의 자본은 각각 |k_i|만큼 감소합니다. 예를 들어, 왼쪽 이웃 L의 자본이
// k_L = 5, 오른쪽 이웃 R의 자본이 k_R = 11인 경우, 마법을 사용하면 k_L = -2,
// k_R = 4가 됩니다.

// 모든 은행의 자본을 0 이상으로 만들기 위해 은행 요정이 수행해야 하는 최소한의
// 마법 횟수는 얼마입니까?

// 입력
// 첫 번째 줄에는 은행의 수 n이 주어집니다. 두 번째 줄에는 n개의 은행의 자본
// k_i가 주어집니다. 각 자본은 공백으로 구분됩니다.

// 출력
// 모든 은행의 자본을 0 이상으로 만들기 위해 필요한 최소 마법 횟수를 출력합니다.

// 풀이 아이디어 ->
// 양수의 누적합 사이클이 될때까지 누적합을 구하면 그 이후부터는 계속해서
// 양수값이 나오므로, 그 때까지 나온 음수의 갯수를 더해서 구해주면 정답

#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);

  int n;
  cin >> n;

  vector<int> a(n);
  for (int i = 0; i < n; i++) {
    cin >> a[i];
  }

  vector<ll> s(2 * n + 1, 0);
  for (int i = 0; i < 2 * n; i++) {
    s[i + 1] = s[i] + a[i % n];
  }

  ll result = 0;

  for (int i = 0; i < n - 1; i++) {
    for (int j = 1; j <= n; j++) {
      if (s[j + i] < s[j - 1]) {
        result += (ll)ceil(abs(s[j + i] - s[j - 1]) / (double)s[n]);
      }
    }
  }

  cout << result;

  return 0;
}
